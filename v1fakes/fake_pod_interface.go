// Code generated by counterfeiter. DO NOT EDIT.
package v1fakes

import (
	"sync"

	meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/kubernetes/typed/core/v1"
	v1api "k8s.io/client-go/pkg/api/v1"
	policy "k8s.io/client-go/pkg/apis/policy/v1beta1"
	restclient "k8s.io/client-go/rest"
)

type FakePodInterface struct {
	CreateStub        func(*v1api.Pod) (*v1api.Pod, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *v1api.Pod
	}
	createReturns struct {
		result1 *v1api.Pod
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *v1api.Pod
		result2 error
	}
	UpdateStub        func(*v1api.Pod) (*v1api.Pod, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *v1api.Pod
	}
	updateReturns struct {
		result1 *v1api.Pod
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *v1api.Pod
		result2 error
	}
	UpdateStatusStub        func(*v1api.Pod) (*v1api.Pod, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 *v1api.Pod
	}
	updateStatusReturns struct {
		result1 *v1api.Pod
		result2 error
	}
	updateStatusReturnsOnCall map[int]struct {
		result1 *v1api.Pod
		result2 error
	}
	DeleteStub        func(name string, options *meta_v1.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		name    string
		options *meta_v1.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCollectionStub        func(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		options     *meta_v1.DeleteOptions
		listOptions meta_v1.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(name string, options meta_v1.GetOptions) (*v1api.Pod, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		name    string
		options meta_v1.GetOptions
	}
	getReturns struct {
		result1 *v1api.Pod
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *v1api.Pod
		result2 error
	}
	ListStub        func(opts meta_v1.ListOptions) (*v1api.PodList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		opts meta_v1.ListOptions
	}
	listReturns struct {
		result1 *v1api.PodList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 *v1api.PodList
		result2 error
	}
	WatchStub        func(opts meta_v1.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		opts meta_v1.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	PatchStub        func(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1api.Pod, err error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		name         string
		pt           types.PatchType
		data         []byte
		subresources []string
	}
	patchReturns struct {
		result1 *v1api.Pod
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1api.Pod
		result2 error
	}
	BindStub        func(binding *v1api.Binding) error
	bindMutex       sync.RWMutex
	bindArgsForCall []struct {
		binding *v1api.Binding
	}
	bindReturns struct {
		result1 error
	}
	bindReturnsOnCall map[int]struct {
		result1 error
	}
	EvictStub        func(eviction *policy.Eviction) error
	evictMutex       sync.RWMutex
	evictArgsForCall []struct {
		eviction *policy.Eviction
	}
	evictReturns struct {
		result1 error
	}
	evictReturnsOnCall map[int]struct {
		result1 error
	}
	GetLogsStub        func(name string, opts *v1api.PodLogOptions) *restclient.Request
	getLogsMutex       sync.RWMutex
	getLogsArgsForCall []struct {
		name string
		opts *v1api.PodLogOptions
	}
	getLogsReturns struct {
		result1 *restclient.Request
	}
	getLogsReturnsOnCall map[int]struct {
		result1 *restclient.Request
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePodInterface) Create(arg1 *v1api.Pod) (*v1api.Pod, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *v1api.Pod
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakePodInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakePodInterface) CreateArgsForCall(i int) *v1api.Pod {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].arg1
}

func (fake *FakePodInterface) CreateReturns(result1 *v1api.Pod, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) CreateReturnsOnCall(i int, result1 *v1api.Pod, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *v1api.Pod
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) Update(arg1 *v1api.Pod) (*v1api.Pod, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *v1api.Pod
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReturns.result1, fake.updateReturns.result2
}

func (fake *FakePodInterface) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakePodInterface) UpdateArgsForCall(i int) *v1api.Pod {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakePodInterface) UpdateReturns(result1 *v1api.Pod, result2 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) UpdateReturnsOnCall(i int, result1 *v1api.Pod, result2 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *v1api.Pod
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) UpdateStatus(arg1 *v1api.Pod) (*v1api.Pod, error) {
	fake.updateStatusMutex.Lock()
	ret, specificReturn := fake.updateStatusReturnsOnCall[len(fake.updateStatusArgsForCall)]
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 *v1api.Pod
	}{arg1})
	fake.recordInvocation("UpdateStatus", []interface{}{arg1})
	fake.updateStatusMutex.Unlock()
	if fake.UpdateStatusStub != nil {
		return fake.UpdateStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateStatusReturns.result1, fake.updateStatusReturns.result2
}

func (fake *FakePodInterface) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *FakePodInterface) UpdateStatusArgsForCall(i int) *v1api.Pod {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return fake.updateStatusArgsForCall[i].arg1
}

func (fake *FakePodInterface) UpdateStatusReturns(result1 *v1api.Pod, result2 error) {
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) UpdateStatusReturnsOnCall(i int, result1 *v1api.Pod, result2 error) {
	fake.UpdateStatusStub = nil
	if fake.updateStatusReturnsOnCall == nil {
		fake.updateStatusReturnsOnCall = make(map[int]struct {
			result1 *v1api.Pod
			result2 error
		})
	}
	fake.updateStatusReturnsOnCall[i] = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) Delete(name string, options *meta_v1.DeleteOptions) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		name    string
		options *meta_v1.DeleteOptions
	}{name, options})
	fake.recordInvocation("Delete", []interface{}{name, options})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(name, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakePodInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakePodInterface) DeleteArgsForCall(i int) (string, *meta_v1.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].name, fake.deleteArgsForCall[i].options
}

func (fake *FakePodInterface) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		options     *meta_v1.DeleteOptions
		listOptions meta_v1.ListOptions
	}{options, listOptions})
	fake.recordInvocation("DeleteCollection", []interface{}{options, listOptions})
	fake.deleteCollectionMutex.Unlock()
	if fake.DeleteCollectionStub != nil {
		return fake.DeleteCollectionStub(options, listOptions)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteCollectionReturns.result1
}

func (fake *FakePodInterface) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakePodInterface) DeleteCollectionArgsForCall(i int) (*meta_v1.DeleteOptions, meta_v1.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return fake.deleteCollectionArgsForCall[i].options, fake.deleteCollectionArgsForCall[i].listOptions
}

func (fake *FakePodInterface) DeleteCollectionReturns(result1 error) {
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) DeleteCollectionReturnsOnCall(i int, result1 error) {
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) Get(name string, options meta_v1.GetOptions) (*v1api.Pod, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		name    string
		options meta_v1.GetOptions
	}{name, options})
	fake.recordInvocation("Get", []interface{}{name, options})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakePodInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakePodInterface) GetArgsForCall(i int) (string, meta_v1.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].name, fake.getArgsForCall[i].options
}

func (fake *FakePodInterface) GetReturns(result1 *v1api.Pod, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) GetReturnsOnCall(i int, result1 *v1api.Pod, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *v1api.Pod
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) List(opts meta_v1.ListOptions) (*v1api.PodList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		opts meta_v1.ListOptions
	}{opts})
	fake.recordInvocation("List", []interface{}{opts})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listReturns.result1, fake.listReturns.result2
}

func (fake *FakePodInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakePodInterface) ListArgsForCall(i int) meta_v1.ListOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].opts
}

func (fake *FakePodInterface) ListReturns(result1 *v1api.PodList, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1api.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) ListReturnsOnCall(i int, result1 *v1api.PodList, result2 error) {
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 *v1api.PodList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 *v1api.PodList
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		opts meta_v1.ListOptions
	}{opts})
	fake.recordInvocation("Watch", []interface{}{opts})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.watchReturns.result1, fake.watchReturns.result2
}

func (fake *FakePodInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakePodInterface) WatchArgsForCall(i int) meta_v1.ListOptions {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].opts
}

func (fake *FakePodInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1api.Pod, err error) {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		name         string
		pt           types.PatchType
		data         []byte
		subresources []string
	}{name, pt, dataCopy, subresources})
	fake.recordInvocation("Patch", []interface{}{name, pt, dataCopy, subresources})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(name, pt, data, subresources...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchReturns.result1, fake.patchReturns.result2
}

func (fake *FakePodInterface) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakePodInterface) PatchArgsForCall(i int) (string, types.PatchType, []byte, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return fake.patchArgsForCall[i].name, fake.patchArgsForCall[i].pt, fake.patchArgsForCall[i].data, fake.patchArgsForCall[i].subresources
}

func (fake *FakePodInterface) PatchReturns(result1 *v1api.Pod, result2 error) {
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) PatchReturnsOnCall(i int, result1 *v1api.Pod, result2 error) {
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1api.Pod
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1api.Pod
		result2 error
	}{result1, result2}
}

func (fake *FakePodInterface) Bind(binding *v1api.Binding) error {
	fake.bindMutex.Lock()
	ret, specificReturn := fake.bindReturnsOnCall[len(fake.bindArgsForCall)]
	fake.bindArgsForCall = append(fake.bindArgsForCall, struct {
		binding *v1api.Binding
	}{binding})
	fake.recordInvocation("Bind", []interface{}{binding})
	fake.bindMutex.Unlock()
	if fake.BindStub != nil {
		return fake.BindStub(binding)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.bindReturns.result1
}

func (fake *FakePodInterface) BindCallCount() int {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return len(fake.bindArgsForCall)
}

func (fake *FakePodInterface) BindArgsForCall(i int) *v1api.Binding {
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	return fake.bindArgsForCall[i].binding
}

func (fake *FakePodInterface) BindReturns(result1 error) {
	fake.BindStub = nil
	fake.bindReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) BindReturnsOnCall(i int, result1 error) {
	fake.BindStub = nil
	if fake.bindReturnsOnCall == nil {
		fake.bindReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.bindReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) Evict(eviction *policy.Eviction) error {
	fake.evictMutex.Lock()
	ret, specificReturn := fake.evictReturnsOnCall[len(fake.evictArgsForCall)]
	fake.evictArgsForCall = append(fake.evictArgsForCall, struct {
		eviction *policy.Eviction
	}{eviction})
	fake.recordInvocation("Evict", []interface{}{eviction})
	fake.evictMutex.Unlock()
	if fake.EvictStub != nil {
		return fake.EvictStub(eviction)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.evictReturns.result1
}

func (fake *FakePodInterface) EvictCallCount() int {
	fake.evictMutex.RLock()
	defer fake.evictMutex.RUnlock()
	return len(fake.evictArgsForCall)
}

func (fake *FakePodInterface) EvictArgsForCall(i int) *policy.Eviction {
	fake.evictMutex.RLock()
	defer fake.evictMutex.RUnlock()
	return fake.evictArgsForCall[i].eviction
}

func (fake *FakePodInterface) EvictReturns(result1 error) {
	fake.EvictStub = nil
	fake.evictReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) EvictReturnsOnCall(i int, result1 error) {
	fake.EvictStub = nil
	if fake.evictReturnsOnCall == nil {
		fake.evictReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.evictReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePodInterface) GetLogs(name string, opts *v1api.PodLogOptions) *restclient.Request {
	fake.getLogsMutex.Lock()
	ret, specificReturn := fake.getLogsReturnsOnCall[len(fake.getLogsArgsForCall)]
	fake.getLogsArgsForCall = append(fake.getLogsArgsForCall, struct {
		name string
		opts *v1api.PodLogOptions
	}{name, opts})
	fake.recordInvocation("GetLogs", []interface{}{name, opts})
	fake.getLogsMutex.Unlock()
	if fake.GetLogsStub != nil {
		return fake.GetLogsStub(name, opts)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getLogsReturns.result1
}

func (fake *FakePodInterface) GetLogsCallCount() int {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	return len(fake.getLogsArgsForCall)
}

func (fake *FakePodInterface) GetLogsArgsForCall(i int) (string, *v1api.PodLogOptions) {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	return fake.getLogsArgsForCall[i].name, fake.getLogsArgsForCall[i].opts
}

func (fake *FakePodInterface) GetLogsReturns(result1 *restclient.Request) {
	fake.GetLogsStub = nil
	fake.getLogsReturns = struct {
		result1 *restclient.Request
	}{result1}
}

func (fake *FakePodInterface) GetLogsReturnsOnCall(i int, result1 *restclient.Request) {
	fake.GetLogsStub = nil
	if fake.getLogsReturnsOnCall == nil {
		fake.getLogsReturnsOnCall = make(map[int]struct {
			result1 *restclient.Request
		})
	}
	fake.getLogsReturnsOnCall[i] = struct {
		result1 *restclient.Request
	}{result1}
}

func (fake *FakePodInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.bindMutex.RLock()
	defer fake.bindMutex.RUnlock()
	fake.evictMutex.RLock()
	defer fake.evictMutex.RUnlock()
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePodInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v1.PodInterface = new(FakePodInterface)
